#!/usr/bin/env python

# pyright: reportAny = false, reportUnusedCallResult = false

import argparse
import os
import shutil
import subprocess
from collections.abc import Sequence
from pathlib import Path

MUSIC_DIR = Path(os.environ["HOME"]) / "Music"
MUSIC_LIB_LOCAL = MUSIC_DIR / "library"
EXT_DRIVE = Path("/run/media/winteragain/ext-drive")
MUSIC_LIB_EXT = EXT_DRIVE / "music/library"


def main(argv: Sequence[str] | None = None) -> int:
    """
    Common operations when transferring ripped music files
    """
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(
        dest="cmd",  # TODO: don't need this?
        help="Common operations when transferring ripped music files",
        required=True,
    )

    parser_clean = subparsers.add_parser(
        "clean", help="Clean garbage files generated by MacOS"
    )
    parser_clean.set_defaults(func=clean)

    parser_opus = subparsers.add_parser(
        "clean-opus", help="Remove .opus files when .aif or .flac files are present"
    )
    parser_opus.add_argument(
        "album",
        type=Path,
        help="Directory containing .aif files corresponding to music album",
    )
    parser_opus.set_defaults(func=clean_opus)

    # TODO: support passing multiple albums at once?
    parser_aif_to_flac = subparsers.add_parser(
        "aif-to-flac",
        help="Convert .aif files to .flac and move the .aif/.flac files to their proper final location",
    )
    parser_aif_to_flac.add_argument(
        "album",
        type=Path,
        help="Directory containing .aif files corresponding to music album",
    )
    parser_aif_to_flac.add_argument("-e", "--ext-to-local", action="store_true")
    parser_aif_to_flac.add_argument("--dry-run", action="store_true")
    parser_aif_to_flac.set_defaults(func=aif_to_flac_handler)

    args = parser.parse_args(argv)
    args.func(args)

    return 0


def clean(args: argparse.Namespace) -> None:  # pyright: ignore[reportUnusedParameter]
    for f in MUSIC_DIR.rglob("*"):
        if f.name.startswith("._") or f.name == ".DS_Store":
            f.unlink()
            print(f"Deleted {f}")


def clean_opus(args: argparse.Namespace) -> None:
    if not args.album.is_dir():
        print("Must provide a directory")
        raise SystemExit(1)

    aif_or_flac = [
        f for f in args.album.glob("*.flac") if f.suffix in {".aif", ".flac"}
    ]
    if len(aif_or_flac) > 0:
        for opus in args.album.glob("*.opus"):
            opus.unlink()
    else:
        print("No .aif or .flac files present")
        raise SystemExit(1)


def aif_to_flac_handler(args: argparse.Namespace) -> None:
    if not args.album.is_dir():
        print("Must provide a directory")
        raise SystemExit(1)

    if not os.path.ismount(EXT_DRIVE):
        print(f"{EXT_DRIVE} not mounted")
        raise SystemExit(1)

    for aif in args.album.glob("*.aif"):
        flac = aif.with_suffix(".flac")
        if not flac.is_file():
            if args.dry_run:
                print(f"Convert .aif to .flac: {aif} -> {flac}")
            else:
                subprocess.run(["ffmpeg", "-i", aif, flac])
        else:
            print(f".flac file already exists: {flac}")

    # TODO: better handling of relative paths like ./library?
    if args.ext_to_local:
        move_flac_to_local(args.album, args.dry_run)
    else:
        move_aif_to_ext_drive(args.album, args.dry_run)


def move_aif_to_ext_drive(album: Path, dry_run: bool) -> None:
    for aif in album.glob("*.aif"):
        aif_abs = aif.resolve()
        aif_rel_lib_local = aif_abs.relative_to(MUSIC_LIB_LOCAL)
        aif_rel_lib_ext = MUSIC_LIB_EXT / aif_rel_lib_local
        if not aif_rel_lib_ext.is_file():
            if dry_run:
                if not aif_rel_lib_ext.parent.exists():
                    print(f"Create parent directory: {aif_rel_lib_ext.parent}")
                print(f"Move .aif: {aif} -> {aif_rel_lib_local}")
            else:
                aif_rel_lib_ext.parent.mkdir(parents=True, exist_ok=True)
                shutil.move(aif, aif_rel_lib_ext)
        else:
            print(f".aif file already exists: {aif_rel_lib_ext}")


def move_flac_to_local(album: Path, dry_run: bool) -> None:
    for flac in album.glob("*.flac"):
        flac_abs = flac.resolve()
        flac_rel_lib_ext = flac_abs.relative_to(MUSIC_LIB_EXT)
        flac_rel_lib_local = MUSIC_LIB_LOCAL / flac_rel_lib_ext
        if not flac_rel_lib_local.is_file():
            if dry_run:
                if not flac_rel_lib_local.parent.exists():
                    print(f"Create parent directory: {flac_rel_lib_local.parent}")
                print(f"Move .flac: {flac} -> {flac_rel_lib_local}")
            else:
                flac_rel_lib_local.parent.mkdir(parents=True, exist_ok=True)
                shutil.move(flac, flac_rel_lib_local)
        else:
            print(f".flac file already exists: {flac_rel_lib_local}")


if __name__ == "__main__":
    raise SystemExit(main())
